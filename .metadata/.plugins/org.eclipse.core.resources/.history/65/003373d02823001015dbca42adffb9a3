#include "imu.h"
#include "stm32wbxx_hal_i2c.h"
// bring in the I2C1 handle defined elsewhere
extern I2C_HandleTypeDef hi2c1;

static void _delay_ms(uint32_t ms) { HAL_Delay(ms); }



#define BNO055_ADDR       (0x28 << 1)

// Register offsets
#define BNO055_OPR_MODE   0x3D
#define BNO055_PWR_MODE   0x3E
#define BNO055_CALIB_STAT 0x35
#define BNO055_EULER_H    0x1A

// Modes
#define OPERATION_MODE_CONFIG 0x00
#define OPERATION_MODE_NDOF   0x0C
#define POWER_MODE_NORMAL     0x00




int BNO055_Init(void)
{

}

int BNO055_SetMode(uint8_t mode, uint32_t mem_addr)
{
    pyb.delay(100)
    self.i2c.mem_write(0x00, self.address, 0x3E)

    if (HAL_I2C_Mem_Read(&hi2c1, BNO055_ADDR, mem_addr , I2C_MEMADD_SIZE_8BIT, imuData, 8, HAL_MAX_DELAY) != HAL_OK)
    {
        printf("TMP117 read error!\n");
        return -999.0f;  // Return a clearly erroneous value to indicate a failure
    }

    HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(
    I2C_HandleTypeDef *hi2c,

    uint16_t DevAddress,

    uint16_t MemAddress,

    uint16_t MemAddSize,

    uint8_t *pData,

    uint16_t Size);


    pyb.delay(100)
    self.i2c.mem_write(0x00, 0x28, 0x3D)
    pyb.delay(100)
    self.i2c.mem_write(mode, 0x28, 0x3D)
    pyb.delay(1000)
    status = self.i2c.mem_read(1, 0x28, 0x39)
    print("Status is:" + str(status))




}

int BNO055_GetCalibrationStatus(uint8_t *sys, uint8_t *gyro,
                                uint8_t *accel, uint8_t *mag)
{

}

int BNO055_GetEuler(int16_t *heading, int16_t *roll, int16_t *pitch)
{

}
